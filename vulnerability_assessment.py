# vulnerability_assessment.py (Refined for Clarity)
import numpy as np


def calculate_skewness(layer):
    """Calculates the skewness of a weight layer, handling zero standard deviation."""
    std_dev = np.std(layer)
    if std_dev == 0:
        return 0.0
    return np.mean(((layer - np.mean(layer)) / std_dev) ** 3)


def calculate_kurtosis(layer):
    """Calculates the kurtosis of a weight layer, handling zero standard deviation."""
    std_dev = np.std(layer)
    if std_dev == 0:
        return 0.0
    return np.mean(((layer - np.mean(layer)) / std_dev) ** 4)


def assess_vulnerabilities(weights, baseline_mean=None, baseline_std=None, threshold_factor=2.0):
    """
    Assesses vulnerabilities by comparing current model weights against a statistical baseline.
    If no baseline is provided, it calculates metrics needed to create one.
    """
    if not weights:
        return {"anomalies": [], "current_mean": 0.0, "current_std": 0.0}

    # Calculate the statistical moments for the current model's weights
    weight_norms = [np.linalg.norm(layer) for layer in weights]
    skewness = [calculate_skewness(layer) for layer in weights]
    kurtosis = [calculate_kurtosis(layer) for layer in weights]

    current_mean = np.mean(weight_norms)
    current_std = np.std(weight_norms)

    # If a baseline is provided, perform anomaly detection
    anomalies = []
    if baseline_mean is not None and baseline_std is not None and baseline_std > 0:
        anomaly_threshold = baseline_mean + threshold_factor * baseline_std
        for i, norm in enumerate(weight_norms):
            status = "anomaly" if norm > anomaly_threshold else "normal"
            anomalies.append({
                "layer_index": i,
                "norm": float(norm),
                "skewness": float(skewness[i]),
                "kurtosis": float(kurtosis[i]),
                "status": status,
            })

    # Return both the current stats (for baseline adaptation) and any detected anomalies
    return {
        "anomalies": anomalies,
        "current_mean": float(current_mean),
        "current_std": float(current_std)
    }